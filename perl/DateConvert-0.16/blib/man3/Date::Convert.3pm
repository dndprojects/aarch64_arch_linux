.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Convert 3"
.TH Convert 3 "2000-01-27" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Convert \- Convert Between any two Calendrical Formats
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Date::DateCalc;
\&
\&        $date=new Date::Convert::Gregorian(1997, 11, 27);
\&        @date=$date\->date;
\&        convert Date::Convert::Hebrew $date;
\&        print $date\->date_string, "\en";
.Ve
.PP
Currently defined subclasses:
.PP
.Vb 4
\&        Date::Convert::Absolute
\&        Date::Convert::Gregorian
\&        Date::Convert::Hebrew
\&        Date::Convert::Julian
.Ve
.PP
Date::Convert is intended to allow you to convert back and forth between
any arbitrary date formats (ie. pick any from: Gregorian, Julian, Hebrew,
Absolute, and any others that get added on).  It does this by having a
separate subclass for each format, and requiring each class to provide
standardized methods for converting to and from the date format of the base
class.  In this way, instead of having to code a conversion routine for
going between and two arbitrary formats foo and bar, the function only
needs to convert foo to the base class and the base class to bar.  Ie:
.PP
.Vb 1
\&        Gregorian <\-\-> Base class <\-\-> Hebrew
.Ve
.PP
The base class includes a \fBConvert\fR method to do this transparently.
.PP
Nothing is exported because it wouldn't make any sense to export.  :)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Fucntion can be split into several categories:
.IP "\(bu" 4
Universal functions available for all subclasses (ie. all formats).  The
fundamental conversion routines fit this category.
.IP "\(bu" 4
Functions that are useful but don't necessarily make sense for all
subclasses.  The overwhelming majority of functions fall into this
category.  Even such seemingly universal concepts as year, for instance,
don't apply to all date formats.
.IP "\(bu" 4
Private functions that are required of all subclasses, ie. \fBinitialize\fR.
These should \fInot\fR be called by users.
.PP
Here's the breakdown by category:
.SS "Functions Defined for all Subclasses"
.IX Subsection "Functions Defined for all Subclasses"
.IP "new" 4
.IX Item "new"
Create a new object in the specified format with the specified start
paramaters, ie. \f(CW\*(C`$date = new Date::Convert::Gregorian(1974, 11, 27)\*(C'\fR.  The
start parameters vary with the subclass.  My personal preference is to
order in decreasing order of generality (ie. year first, then month, then
day, or year then week, etc.)
.Sp
This can have a default date, which should probably be \*(L"today\*(R".
.IP "date" 4
.IX Item "date"
Extract the date in a format appropriate for the subclass.  Preferably this
should match the format used with \fBnew\fR, so
.Sp
.Vb 1
\&        (new date::Convert::SomeClass(@a))\->date;
.Ve
.Sp
should be an identity function on \f(CW@a\fR if \f(CW@a\fR was in a legitmate format.
.IP "date_string" 4
.IX Item "date_string"
Return the date in a pretty format.
.IP "convert" 4
.IX Item "convert"
Change the date to a new format.
.SS "Non-universal functions"
.IX Subsection "Non-universal functions"
.IP "year" 4
.IX Item "year"
Return just the year element of date.
.IP "month" 4
.IX Item "month"
Just like year.
.IP "day" 4
.IX Item "day"
Just like year and month.
.IP "is_leap" 4
.IX Item "is_leap"
Boolean.  Note that (for \fB::Hebrew\fR and \fB::Gregorian\fR, at least!) this
can be also be used as a static.  That is, you can either say
	\f(CW$date\fR\->is_leap
or
	is_leap Date::Convert::Hebrew 5757
.SS "Private functions that are required of all subclasses"
.IX Subsection "Private functions that are required of all subclasses"
You shouldn't call these, but if you want to add a class, you'll need to
write them!  Or it, since at the moment, there's only one.
.IP "initialize" 4
.IX Item "initialize"
Read in args and initialize object based on their values.  If there are no
args, initialize with the base class's initialize (which will initialize in
the default way described above for \fBnew\fR.)  Note the American spelling of
\&\*(L"initialize\*(R": \*(L"z\*(R", not \*(L"s\*(R".
.SH "SUBCLASS SPECIFIC NOTES"
.IX Header "SUBCLASS SPECIFIC NOTES"
.SS "Absolute"
.IX Subsection "Absolute"
The \*(L"Absolute\*(R" calendar is just the number of days from a certain reference
point.  Calendar people should recognize it as the \*(L"Julian Day Number\*(R" with
one minor modification:  When you convert a Gregorian day n to absolute,
you get the \s-1JDN\s0 of the Gregorian day from noon on.
.PP
Since \*(L"absolute\*(R" has no notion of years it is an extremely easy calendar
for conversion purposes.  I stole the \*(L"absolute\*(R" calendar format from
Reingold's emacs calendar mode, for debugging purposes.
.PP
The subclass is little more than the base class, and as the lowest common
denominator, doesn't have any special functions.
.SS "Gregorian"
.IX Subsection "Gregorian"
The Gregorian calendar is a purely solar calendar, with a month that is
only an approximation of a lunar month.  It is based on the old Julian
(Roman) calendar.  This is the calendar that has been used by most of the
Western world for the last few centuries.  The time of its adoption varies
from country to country.  This \fB::Gregorian\fR allows you to extrapolate
back to 1 A.D., as per the prorgamming tradition, even though the calendar
definitely was not in use then.
.PP
In addition to the required methods, \fBGregorian\fR also has \fByear\fR,
\&\fBmonth\fR, \fBday\fR, and \fBis_leap\fR methods.  As mentioned above, \fBis_leap\fR
can also be used statically.
.SS "Hebrew"
.IX Subsection "Hebrew"
This is the traditional Jewish calendar.  It's based on the solar year, on
the lunar month, and on a number of additional rules created by Rabbis to
make life tough on people who calculate calendars.  :)  If you actually wade
through the source, you should note that the seventh month really does come
before the first month, that's not a bug.
.PP
It comes with the following additional methods: \fByear\fR, \fBmonth\fR, \fBday\fR,
\&\fBis_leap\fR, \fBrosh\fR, \fBpart_add\fR, and \fBpart_mult\fR.  \fBrosh\fR returns the
absolute day corresponding to \*(L"Rosh HaShana\*(R" (New year) for a given year,
and can also be invoked as a static.  \fBpart_add\fR and \fBpart_mult\fR are
useful functions for Hebrew calendrical calculations are not for much else;
if you're not familiar with the Hebrew calendar, don't worry about them.
.SS "Islamic"
.IX Subsection "Islamic"
The traditional Muslim calendar, a purely lunar calendar with a year that
is a rough approximation of a solar year.  Currently unimplemented.
.SS "Julian"
.IX Subsection "Julian"
The old Roman calendar, allegedly named for Julius Caesar.  Purely solar,
with a month that is a rough approximation of the lunar month.  Used
extensively in the Western world up to a few centuries ago, then the West
gradually switched over to the more accurate Gregorian.  Now used only by
the Eastern Orthodox Church, \s-1AFAIK.\s0
.SH "ADDING NEW SUBCLASSES"
.IX Header "ADDING NEW SUBCLASSES"
This section describes how to extend \fBDate::Convert\fR to add your favorite
date formats.  If you're not interested, feel free to skip it.  :)
.PP
There are only three function you \fIhave\fR to write to add a new subclass:
you need \fBinitialize\fR, \fBdate\fR, and \fBdate_string\fR.  Of course, helper
functions would probably help. . .  You do \fInot\fR need to write a \fBnew\fR or
\&\fBconvert\fR function, since the base class handles them nicely.
.PP
First, a quick conceptual overhaul: the base class uses an \*(L"absolute day
format\*(R" (basically \*(L"Julian day format\*(R") borrowed from \fBemacs\fR.  This is
just days numbered absolutely from an extremely long time ago.  It's really
easy to use, particularly if you have emacs and emacs' \fBcalendar mode\fR.
Each Date::Convert object is a reference to a hash (as in all \s-1OO\s0 perl) and
includes a special \*(L"absol\*(R" value stored under a reserved \*(L"absol\*(R" key.  When
\&\fBinitialize\fR initializes an object, say a Gregorian date, it stores
whatever data it was given in the object and it also calculates the \*(L"absol\*(R"
equivalent of the date and stores it, too.  If the user converts to another
date, the object is wiped clean of all data except \*(L"absol\*(R".  Then when the
\&\fBdate\fR method for the new format is called, it calculates the date in the
new format from the \*(L"absol\*(R" data.
.PP
Now that I've thoroughly confused you, here's a more compartmentalized
version:
.IP "initialize" 4
.IX Item "initialize"
Take the date supplied as argument as appropriate to the format, and
convert it to \*(L"absol\*(R" format.  Store it as \f(CW$$self{\*(Aqabsol\*(Aq}\fR.  You might
also want to store other data, ie. \fB::Gregorian\fR stores \f(CW$$self{\*(Aqyear\*(Aq}\fR,
\&\f(CW$$self{\*(Aqmonth\*(Aq}\fR, and \f(CW$$self{\*(Aqday\*(Aq}\fR.  If no args are supplied,
explicitly call the base class's initialize,
ie. \f(CW\*(C`Date::Convert::initialize\*(C'\fR, to initialize with a default 'absol' date
and nothing else.
.Sp
\&\fI\s-1NOTE:\s0\fR  I may move the default behavior into the new constructor.
.IP "date" 4
.IX Item "date"
Return the date in a appropriate format.  Note that the only fact that
\&\fBdate\fR can take as given is that \f(CW$$self{\*(Aqabsol\*(Aq}\fR is defined, ie. this
object may \fInot\fR have been initialized by the \fBinitialize\fR of this
object's class.  For instance, you might have it check if \f(CW$$self{\*(Aqyear\*(Aq}\fR
is defined.  If it is, then you have the year component, otherwise, you
calculate year from \f(CW$$self{\*(Aqabsol\*(Aq}\fR.
.IP "date_string" 4
.IX Item "date_string"
This is the easy part.  Just call date, then return a pretty string based
on the values.
.PP
\&\fI\s-1NOTE:\s0\fR The \fB::Absolute\fR subclass is a special case, since it's nearly an
empty subclass (ie. it's just the base class with the required methods
filled out).  Don't use it as an example!  The easiest code to follow would
have been \fB::Julian\fR except that Julian inherits from \fB::Gregorian\fR.
Maybe I'll reverse that. . .
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&        #!/usr/local/bin/perl5 \-w
\&
\&        use Date::Convert;
\&
\&        $date=new Date::Convert::Gregorian(1974, 11, 27);
\&        convert Date::Convert::Hebrew $date;
\&        print $date\->date_string, "\en";
.Ve
.PP
My Gregorian birthday is 27 Nov 1974.  The above prints my Hebrew birthday.
.PP
.Vb 2
\&        convert Date::Convert::Gregorian $date;
\&        print $date\->date_string, "\en";
.Ve
.PP
And that converts it back and prints it in Gregorian.
.PP
.Vb 4
\&        $guy = new Date::Convert::Hebrew (5756, 7, 8);
\&        print $guy\->date_string, " \-> ";
\&        convert Date::Convert::Gregorian $guy;
\&        print $guy\->date_string, "\en";
.Ve
.PP
Another day, done in reverse.
.PP
.Vb 3
\&        @a=(5730, 3, 2);
\&        @b=(new Date::Convert::Hebrew @a)\->date;
\&        print "@a\en@b\en";
.Ve
.PP
The above should be an identity for any list \f(CW@a\fR that represents a
legitimate date.
.PP
.Vb 1
\&        #!/usr/local/bin/perl \-an
\&
\&        use Date::Convert;
\&
\&        $date = new Date::Convert::Gregorian @F;
\&        convert Date::Convert::Hebrew $date;
\&        print $date\->date_string, "\en";
.Ve
.PP
And that's a quick Greg \-> Hebrew conversion program, for those times when
people ask.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBperl\fR\|(1), \fBDate::DateCalc\fR\|(3)
.SH "VERSION"
.IX Header "VERSION"
Date::Convert 0.15 (pre-alpha)
.SH "AUTHOR"
.IX Header "AUTHOR"
Mordechai T. Abzug <morty@umbc.edu>
.SH "ACKNOWLEDGEMENTS AND FURTHER READING"
.IX Header "ACKNOWLEDGEMENTS AND FURTHER READING"
The basic idea of using astronomical dates as an intermediary between all
calculations comes from Dershowitz and Reingold.  Reingold's code is the
basis of emacs's calendar mode.  Two papers describing their work (which I
used to own, but lost!  Darn.) are:
.PP
``Calendrical Calculations'' by Nachum Dershowitz and Edward M. Reingold,
\&\fISoftware\*(--Practice and Experience\fR, Volume 20, Number 9 (September,
1990), pages 899\-928.  ``Calendrical Calculations, Part \s-1II:\s0 Three
Historical Calendars'' by E. M. Reingold, N. Dershowitz, and S. M. Clamen,
\&\fISoftware\*(--Practice and Experience\fR, Volume 23, Number 4 (April, 1993),
pages 383\-404.
.PP
They were also scheduled to come out with a book on calendrical
calculations in Dec. 1996, but as of March 1997, it still isn't out yet.
.PP
The Hebrew calendrical calculations are largely based on a cute little
English book called \fIThe Hebrew Calendar\fR (I think. . .)  in a box
somewhere at my parents' house.  (I'm organized, see!)  I'll have to dig
around next time I'm there to find it.  If you want to access the original
Hebrew sources, let me give you some advice: Hilchos Kiddush HaChodesh in
the Mishneh Torah is not the Rambam's most readable treatment of the
subject.  He later wrote a little pamphlet called \*(L"MaAmar HaEibur\*(R" which is
both more complete and easier to comprehend.  It's included in \*(L"Mich't'vei
HaRambam\*(R" (or some such; I've \fIgot\fR to visit that house), which was
reprinted just a few years ago.
.PP
Steffen Beyer's Date::DateCalc showed me how to use MakeMaker and write \s-1POD\s0
documentation.  Of course, any error is my fault, not his!
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997 by Mordechai T. Abzug
.SH "LICENSE STUFF"
.IX Header "LICENSE STUFF"
You can distribute, modify, and otherwise mangle Date::Convert under the
same terms as perl.
